# 线程基础知识复习

## 1. 四大口诀

1、高内聚低耦合前提下，封装思想（线程操作资源类）

2、判断、干活、通知

3、防止虚假唤醒，wait方法要注意使用while判断

4、注意标志位flag，可能是volatile的

## 2. 为什么多线程及其重要

硬件方面：摩尔定律失效

> 摩尔定律：
> 它是由英特尔创始人之一Gordon Moore(戈登·摩尔)提出来的。其内容为：
> 当价格不变时，集成电路上可容纳的元器件的数目约每隔18-24个月便会增加一倍，性能也将提升一倍。
> 换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。
>
> 可是从2003年开始CPU主频已经不再翻倍，而是采用多核而不是更快的主频。
>
> 摩尔定律失效。
>
> 在主频不再提高且核数在不断增加的情况下，要想让程序更快就要用到并行或并发编程。

软件方面：高并发系统，异步 + 回调等生产需求。

## 3. Java多线程相关概念

进程：是程序的⼀次执行，是系统进行资源分配和调度的独立单位，每⼀个进程都有它自己的内存空间和系统资源。

线程：在同⼀个进程内又可以执行多个任务，而这每⼀个任务我们就可以看做是⼀个线程；一个进程会有1个或多个线程的。

## 4. 用户线程和守护线程

Java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程，false表示是用户线程。

守护线程：是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程。

用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。

```java
public class DaemonDemo {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t 开始运行，" + (Thread.currentThread().isDaemon() ? "守护线程" : "用户线程"));
            while (true) {

            }
        }, "t1");
        //线程的daemon属性为true表示是守护线程，false表示是用户线程
        t1.setDaemon(true);
        t1.start();
        //3秒钟后主线程再运行
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("----------main线程运行完毕");
    }
}

```

> 1、当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出。
>
> 2、如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出
> 了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出。
>
> 3、设置守护线程，需要在start()方法之前进行。




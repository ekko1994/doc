* [一、缓存预热](#%E4%B8%80%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD)
  * [宕机](#%E5%AE%95%E6%9C%BA)
  * [问题排查](#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5)
  * [解决方案](#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
  * [总结](#%E6%80%BB%E7%BB%93)
* [二、缓存雪崩](#%E4%BA%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9)
  * [数据库服务器崩溃（1）](#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%831)
  * [问题排查](#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-1)
  * [问题分析](#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90)
  * [解决方案（道）](#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%81%93)
  * [解决方案（术）](#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%AF)
  * [总结](#%E6%80%BB%E7%BB%93-1)
* [三、缓存击穿](#%E4%B8%89%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF)
  * [数据库服务器崩溃（2）](#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%832)
  * [问题排查](#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-2)
  * [问题分析](#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1)
  * [解决方案（术）](#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%AF-1)
  * [总结](#%E6%80%BB%E7%BB%93-2)
* [四、缓存穿透](#%E5%9B%9B%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F)
  * [数据库服务器崩溃（3）](#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%833)
  * [问题排查](#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-3)
  * [问题分析](#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2)
  * [解决方案（术）](#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%AF-2)
  * [总结](#%E6%80%BB%E7%BB%93-3)
* [五、性能指标监控](#%E4%BA%94%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7)
  * [性能指标：Performance](#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87performance)
  * [内存指标：Memory](#%E5%86%85%E5%AD%98%E6%8C%87%E6%A0%87memory)
  * [基本活动指标：Basic activity](#%E5%9F%BA%E6%9C%AC%E6%B4%BB%E5%8A%A8%E6%8C%87%E6%A0%87basic-activity)
  * [持久性指标：Persistence](#%E6%8C%81%E4%B9%85%E6%80%A7%E6%8C%87%E6%A0%87persistence)
  * [错误指标：Error](#%E9%94%99%E8%AF%AF%E6%8C%87%E6%A0%87error)
  * [监控方式](#%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F)
    * [benchmark](#benchmark)
    * [monitor](#monitor)
    * [slowlog](#slowlog)

# 一、缓存预热

## 宕机

## 问题排查

1、请求数量较高

2、主从之间数据吞吐量较大，数据同步操作频度较高

## 解决方案

前置准备工作：

1、日常例行统计数据访问记录，统计访问频度较高的热点数据

2、利用LRU数据删除策略，构建数据留存队列

​			例如：storm与kafka配合

准备工作：

3、将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据

4、利用分布式多服务器同时进行数据读取，提速数据加载过程

实施：

1、使用脚本程序固定触发数据预热过程

2、如果条件允许，使用了CDN（内容分发网络），效果会更好

## 总结

缓存预热就是系统启动前，提前将数据相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询实现被预热的缓存数据！

# 二、缓存雪崩

## 数据库服务器崩溃（1）

1、系统平稳运行过程中，忽然数据库连接量激增

2、应用服务器无法及时处理请求

3、大量408,500错误页面出现

4、客户反复刷新页面获取数据

5、数据库崩溃

6、应用服务器崩溃

7、重启应用服务器无效

8、redis服务器崩溃

9、redis集群崩溃

10、重启数据库后再次被瞬间流量放倒

## 问题排查

1、在一个较短的时间内，缓存中较多的key集中过期

2、此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据

3、数据库同时接收到大量的请求无法及时处理

4、redis大量请求被积压，开始出现超时现象

5、数据库流量激增，数据库崩溃

6、重启后仍然面对缓存中无数据可用

7、redis服务器资源被严重占用，redis服务器崩溃

8、redis集群呈现崩溃，集群瓦解

9、应用服务器无法及时得到数据库响应请求，来自客户端的请求数量越来越多，应用服务器崩溃

10、应用服务器，redis，数据库全部重启，效果不理想

## 问题分析

- 短时间范围内
- 大量key集中过期

## 解决方案（道）

1、更多的页面静态化处理

2、构建多级缓存架构

​			Nginx缓存+redis缓存+ehcache缓存

3、检测mysql严重耗时业务进行优化

​			对数据库的瓶颈排查：例如超时查询、耗时较高事务等

4、灾难预警机制

​       监控redis服务器性能指标

- CPU占用、CPU使用率
- 内存容量
- 查询平均响应时间
- 线程数

5、限流、降级

​		短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问

## 解决方案（术）

1、LRU与LFU切换

2、数据有效期策略调整

- 根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟
- 过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量

3、超热数据使用永久key

4、定期维护（自动+人工）

​			对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时

5、加锁

​			慎用！

## 总结

缓存雪崩就是瞬间过期数据量太大，导致数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快四调整。

![](https://github.com/jackhusky/doc/tree/master/redis/images/缓存雪崩.png)

# 三、缓存击穿

## 数据库服务器崩溃（2）

1、系统平稳运行过程中

2、数据库连接量瞬间激增

3、redis服务器无大量key过期

4、redis内存平稳、无波动

5、redis服务器CPU正常

6、数据库崩溃

## 问题排查

1、redis中某个key过期，该key访问量巨大

2、多个数据请求从服务器直接压到redis后，均为命中

3、redis在短时间内发起了大量对数据库中同一数据的访问

## 问题分析

- 单个key高热数据
- key过期

## 解决方案（术）

1、预先设定

​		以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长

​		注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势

2、现场调整

​			监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key

3、后台刷新数据

​			启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失

4、二级缓存

​			设置不同的失效时间，保证不会被**同时**淘汰就行

5、加锁

​			分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！

## 总结

缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理处理即可

# 四、缓存穿透

## 数据库服务器崩溃（3）

1、系统平稳运行过程中

2、应用服务器流量随时间增量较大

3、redis服务器命中率随时间逐步降低

4、redis内存平稳，内存无压力

5、redis服务器CPU占用激增

6、数据库服务器压力激增

7、数据库崩溃

## 问题排查

1、redis中大面积出现未命中

2、出现非正常URL访问（比如根据根本不存在的id去访问）

## 问题分析

- 获取的数据在数据库中也不存在，数据库查询未得到对应数据
- redis获取到null数据未进行持久化，直接返回
- 下次此类数据到达重复上述过程
- 出现黑客攻击服务器

## 解决方案（术）

1、缓存null

​			对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟

2、白名单策略

- 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，方形，加载异常数据时直接拦截（效率偏低）
- 使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）

3、实施监控

​	实施监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比

- 非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象

- 活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象

  根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）

4、key加密

​			问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验

​			例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问

## 总结

缓存击穿放了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时**报警**。应对策略应该在临时预案防范方面多做文章。

无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。

# 五、性能指标监控

**监控指标**

- 性能指标：Performance
- 内存指标：Memory
- 基本活动指标：Basic activity
- 持久性指标：Persistence
- 错误指标：Error

## 性能指标：Performance

| Name                      | Description              |
| ------------------------- | ------------------------ |
| latency                   | redis响应一个请求的时间  |
| instantaneous_ops_per_sec | 平均每秒处理请求总述     |
| hit rate(calculated)      | 缓存命中率（机损出来的） |

## 内存指标：Memory

| Name                    | Description                                |
| ----------------------- | ------------------------------------------ |
| used_memory             | 已使用内存                                 |
| mem_fragmentation_ratio | 内存碎片率                                 |
| evicted_keys            | 由于最大内存限制被移除的key的数量          |
| blocked_clients         | 由于BLPOP,BRPOP,BRPOPLPUSH而备阻塞的客户端 |

## 基本活动指标：Basic activity

| Name                       | Description            |
| -------------------------- | ---------------------- |
| connected_clients          | 客户端连接数           |
| connected_slaves           | slave数量              |
| master_last_io_seconds_ago | 最近一次主从交互的秒数 |
| keyspace                   | 数据库中的key值总述    |

## 持久性指标：Persistence

| Name                        | Description                        |
| --------------------------- | ---------------------------------- |
| rdb_last_save_time          | 最后一次持久化保存到磁盘的时间戳   |
| rdb_changes_since_last_save | 自最后一次持久化依赖数据库的更改数 |

## 错误指标：Error

| Name                           | Description                           |
| ------------------------------ | ------------------------------------- |
| rejected_connections           | 由于达到maxclient限制而被拒绝的连接数 |
| keyspace_misses                | key值查找失败（没有命中）次数         |
| master_link_down_since_seconds | 主从断开的持续时间（以秒为单位）      |

## 监控方式

- 工具
  - cloud Insight Redis
  - Prometheus
  - Redis-stat
  - Redis-faina
  - RedisLive
  - zabbix
- 命令
  - benchmark
  - redis cli
    - monitor
    - slowlog

### benchmark

- 命令

  ```shell
  redis-benchmark [-h] [-p] [-c] [-n <requests>] [-k]
  ```

- 范例1

  ```shell
  redis-benchmark
  ```

  说明：50个连接，10000次请求对应的性能

- 范例2

  ```shell
  redis-benchmark -c 100 -n 5000
  ```

  说明：100个连接，5000次请求对应的性能

### monitor

- 命令

  ```shell
  127.0.0.1:6380> MONITOR
  ```

### slowlog

- 命令

  ```shell
  slowlog [operator]
  ```

  - get：获取慢查询日志
  - len：获取慢查询日志条目数
  - reset：重置慢查询日志

- 相关配置

  ```conf
  slowlog-log-slower-than 1000 # 设置慢查询的时间下线，单位：微秒
  slow-max-len 100 #设置慢查询命令对应的日志显示长度，单位：命令数
  ```

  
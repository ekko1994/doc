# 一、NoSql概述

NoSQL(NoSQL = Not Only SQL )，作为关系型数据库的补充。

作用：应对基于海量用户和海量数据前提下的数据处理问题。

特征：

- 可扩容，可伸缩
- 大数据量下高性能
- 灵活的数据模型
- 高可用

**解决方案（电商场景）**

1、商品的基本信息（名称，价格，厂商）MySql

2、商品附加信息（描述，详情，评论）MongoDB

3、图片信息（分布式文件系统）

4、搜索关键字（ES、Lucene、solr）

5、热点信息（高频，波段性）Redis、memchche、tair

# 二、Redis基础

## 1、概念

概念：C语音开发的一个开源的高性能键值对数据库。

特征：

- 数据间没有必然的关联关系
- 内部采用单线程机制进行工作

- 高性能。50个并发执行100000个请求，读速度110000次/s，写速度81000次/s
- 多数据类型支持
  - 字符串类型 	string
  - 列表类型         list
  - 散列类型         hash
  - 集合类型          set
  - 有序集合类型   sorted_set
- 持久化支持，可以进行数据灾难恢复

## 2、Redis的应用

- 为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息
- 任务队列，如秒杀、抢购、购票排列
- 即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信息
- 时效性信息控制，如验证码控制、控票控制
- 分布式数据共享，如分布式集群架构中的session分离
- 消息队列
- 分布式锁

## 3、Redis 的基本操作

### 3.1、信息添加

```shell
127.0.0.1:6379> set age 100
OK
127.0.0.1:6379> get age
"100"
127.0.0.1:6379> get abc
(nil)
```

### 3.2、帮助

```shell
127.0.0.1:6379> help get

  GET key
  summary: Get the value of a key
  since: 1.0.0
  group: string
```

## 4、数据存储类型

### 4.1、作为缓存使用

1、原始业务功能设计

- 秒杀
- 618
- 双11
- 排队购票

2、运营平台监控到的突发高频访问数据

- 突发时政要闻，被强势关注围观

3、高频、复杂的统计数据

- 在线人数
- 投票排行榜

### 4.2 附加功能

1、系统功能优化或升级

- 单服务器升级集群
- `Session` 管理
- `Token` 管理

## 5、Redis 的5种数据类型

**数据存储格式**

- `redis`自身是一个`Map`，其中所有的数据都采用`key：value`的形式存储
- 数据类型指的是存储的数据的类型，也就是`value`部分的类型，`key`永远都是字符串

### 5.1、string 类型

#### 基本操作

单个数据：

```shell
127.0.0.1:6379> set name zh
OK
127.0.0.1:6379> get name
"zh"
127.0.0.1:6379> del name
(integer) 1
127.0.0.1:6379> del name
(integer) 0
```

多个数据：

```shell
127.0.0.1:6379> mset k1 v1 k2 v2
OK
127.0.0.1:6379> mget k1 k2
1) "v1"
2) "v2"
```

获取字符个数（字符串长度）

```shell
127.0.0.1:6379> set name jack
OK
127.0.0.1:6379> strlen name
(integer) 4
```

追加字符：

```shell
127.0.0.1:6379> append name rose
(integer) 8
127.0.0.1:6379> get name
"jackrose"
127.0.0.1:6379> append k3 v3333
(integer) 5
```

**单数据操作和多数据操作的选择？**

#### 扩展操作

业务场景：

大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键`id`必须保证统一性，不能重复，如何解决？

- 设置数值数据增加指定范围的值

```shell
127.0.0.1:6379> set num 1
OK
127.0.0.1:6379> incr num
(integer) 2
127.0.0.1:6379> get num
"2"
127.0.0.1:6379> incr num
(integer) 3
127.0.0.1:6379> get num
"3"
```

- 设置数值数据减少指定范围的值

```shell
127.0.0.1:6379> decr num
(integer) 2
127.0.0.1:6379> get num
"2"
```

`INCRBY`、`DECRBY`

```shell
127.0.0.1:6379> INCRBY num 10
(integer) 12
127.0.0.1:6379> INCRBYFLOAT num 1.2
"13.199999999999999"
127.0.0.1:6379> get num
"13.199999999999999"

127.0.0.1:6379> DECRBY num 2
(error) ERR value is not an integer or out of range
```

`string`作为数值操作：

- `string`作为`redis`内部存储默认就是一个字符串，当遇到增减类操作`incr`，`decr`时会转成数值型进行计算。
- `redis`所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。
- 注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了`redis`数值上限范围，将报错。

> - `redis`用于控制数据库表主键id，为数据库表主键提供生成策略，保证数据库表主键唯一性
> - 此方案适用于所有数据库，且支持数据库集群

业务场景：

电商商家开启热门商品推荐，热门商品不能一直处于热门期，每种商品热门期维持3天，3天后自动取消热门。

新闻网站会出现热点新闻，热点新闻最大的特征就是时效性，如何自动控制热点新闻的时效性。

- 设置数据具有指定的生命周期

```shell
127.0.0.1:6379> setex tel 10 1
OK
127.0.0.1:6379> get tel
"1"
127.0.0.1:6379> get tel
(nil)
```

#### string 类型应用场景

业务场景：

主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数和微博数量

解决方案：

- 在`redis`中为大V用户设定用户信息，以用户主键和属性值作为`key`，后台设定定时刷新时间

  eg：user:id3506728390:fans ----> 1224432

  ```shell
  127.0.0.1:6379> set user:id00789:fans 1234567
  OK
  127.0.0.1:6379> set user:id00789:blobs 789
  OK
  ```

- 在`redis`中以`json`格式存储大V用户信息，定时刷新

  ```shell
  127.0.0.1:6379> set user:id:00789 {id:00789,blobs:789,fans:1234567}
  OK
  ```

```shell
127.0.0.1:6379> incr user:id:00789:fans
(integer) 1
```

#### key 的设置约定

- 数据库中的热点数据key命名惯例

  ​       表名：主键名：主键值：字段名

  ​       order:      id   :     549   :     name

### 5.2、hash 类型

- 新的存储需求：典型应用存储对象信息
- 存储结构： 一个存储空间保存多个键值对数据
- 底层使用哈希表结构实现数据存储

`hash`存储结构优化：

- 字段数量较少，存储结构有华为类数组结构
- 字段数量较多，存储结构使用`HashMap`结构

#### 基本操作

单个数据：

```shell
127.0.0.1:6379> hset user name zhangsan
(integer) 1
127.0.0.1:6379> hset user age 30
(integer) 1
127.0.0.1:6379> hset user weight 60
(integer) 1
127.0.0.1:6379> hgetall user
1) "name"
2) "zhangsan"
3) "age"
4) "30"
5) "weight"
6) "60"
127.0.0.1:6379> hget user name
"zhangsan"
127.0.0.1:6379> hdel user weight
(integer) 1
127.0.0.1:6379> hgetall user
1) "name"
2) "zhangsan"
3) "age"
4) "30"
```

多个数据：

```shell
127.0.0.1:6379> hmset user name zhangsanfeng weight 77
OK
127.0.0.1:6379> hmget user name age weight
1) "zhangsanfeng"
2) "30"
3) "77"
127.0.0.1:6379> hlen user
(integer) 3
127.0.0.1:6379> HEXISTS user age
(integer) 1
```

#### 扩展操作

- 获取哈希表所有的字段名或字段值

```shell
127.0.0.1:6379> HKEYS user
1) "name"
2) "age"
3) "weight"
127.0.0.1:6379> HVALS user
1) "zhangsanfeng"
2) "30"
3) "77"
```

- 设置指定字段的数值数据增加指定范围的值

```shell
127.0.0.1:6379> HINCRBY user age 1
(integer) 31
```

**注意事项**：

- `hash`类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据没取到，对应的值为`nil`
- `hash`类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但`hash`设计初衷不是为了存储大量对象而设计，不可滥用
- `hgetall`操作可以获取全部属性，如果内部`field`过多，便利整体数据效率会很低，有可能成为数据范围瓶颈

#### hash类型应用场景

业务场景1：

电商网站购物车设计与实现

![](images/hash%E7%BB%93%E6%9E%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png)

- 仅分析购物车的`redis`存储模型：添加、浏览、更改数量、删除、清空

解决方案：

- 以客户id作为`key`，每位客户创建一个hash存储结构存储对应的购物车信息
- 将商品编号作为`field`，购买数量作为value进行存储
- 添加商品：追加全新的field与value
- 浏览：遍历`hash`
- 更改数量：自增、自减，设置value的值
- 删除商品：删除`field`
- 清空：删除`key`

```shell
127.0.0.1:6379> hmset 001 g01:nums 100
OK
127.0.0.1:6379> hmset g01 info {....}
OK
```

```shell
127.0.0.1:6379> HSET 003 g01:nums 200
(integer) 1
127.0.0.1:6379> HGETALL 003
1) "g01:nums"
2) "200"
127.0.0.1:6379> HSETNX 003 g01:nums 400
(integer) 0
```

业务场景2：

双11活动，销售手机充值卡的商家对30、50、100抢购活动，每种1000张

解决方案：

- 以商家`id`作为`key`
- 将参与抢购的商品id作为`field`
- 将参与抢购的商品数量作为对应的`value`
- 抢购时使用降值方式控制产品数量

```shell
127.0.0.1:6379> HINCRBY p01 c50 -1
(integer) 999
127.0.0.1:6379> HINCRBY p01 c100 -20
(integer) 980
127.0.0.1:6379> HGETALL p01
1) "c30"
2) "1000"
3) "c50"
4) "999"
5) "c100"
6) "980"
```

> string 存储对象（json）偏读，hash存储对象偏更新

### 5.3、list类型

- 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分
- 需要的存储结构：一个存储空间保存多个数据，且通过数据可以提现进入顺序
- `list`类型：保存多个数据，底层使用双向链表存储结构实现

#### 基本操作

```shell
127.0.0.1:6379> lpush list1 huawei
(integer) 1
127.0.0.1:6379> lpush list1 apple
(integer) 2
127.0.0.1:6379> lpush list1 microsoft
(integer) 3
127.0.0.1:6379> LRANGE list1 0 2
1) "microsoft"
2) "apple"
3) "huawei"
127.0.0.1:6379> RPUSH list2 a b c
(integer) 3
127.0.0.1:6379> LRANGE list2 0 2
1) "a"
2) "b"
3) "c"
127.0.0.1:6379> LRANGE list1 0 -1
1) "microsoft"
2) "apple"
3) "huawei"
127.0.0.1:6379> LINDEX list1 1
"apple"
127.0.0.1:6379> LLEN list1
(integer) 3
```

获取并移除数据

```shell
127.0.0.1:6379> LPUSH list3 a b c
(integer) 3
127.0.0.1:6379> LPOP list3
"c"
127.0.0.1:6379> LPOP list3
"b"
127.0.0.1:6379> LPOP list3
"a"
```

#### 扩展操作

- 规定时间内获取并移除数据

```shell
127.0.0.1:6379> BLPOP list0 30
```

业务场景：

微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息

如果取消点赞，移除对应好友信息？

- 移除指定数据

  ```shell
  127.0.0.1:6379> rpush 001 a b c d e
  (integer) 5
  127.0.0.1:6379> LRANGE 001 0 -1
  1) "a"
  2) "b"
  3) "c"
  4) "d"
  5) "e"
  127.0.0.1:6379> LREM 001 1 d
  (integer) 1
  127.0.0.1:6379> LRANGE 001 0 -1
  1) "a"
  2) "b"
  3) "c"
  4) "e"
  ```

**注意事项**：

- `list`中保存的数据都是`string`类型的，数据总容量是有限的
- `list`具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作
- 获取全部数据操作结束索引设置为-1
- `list`可以对数据进行分页操作，通常第一页的信息来自于`list`，第二页及更多的信息通过数据库的形式加载

#### list类型应用场景

业务场景：

- twitter、新浪微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝离了表需要将最近关注的粉丝列在前面

- 新闻、资讯类网站如何将最新的新闻或资讯按照发生的时间顺序展示
- 企业运营过程中，系统将产生大量的运营数据，如何保障多台服务器操作日志的同一顺序输出

解决方案：

- 依赖`list`的数据具有顺序的特征对信息进行管理
- 使用队列模型解决多路信息汇总合并的问题
- 使用栈模型解决最新消息的问题

**应用于最新消息展示**

### 5.4、set类型

- 新的存储需求：存储大量的数据，在查询方面提供更高的效率
- 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询
- `set`类型：与`hash`存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的4

#### 基本操作

```shell
127.0.0.1:6379> SADD users zs
(integer) 1
127.0.0.1:6379> SADD users ls
(integer) 1
127.0.0.1:6379> SADD users ww
(integer) 1
127.0.0.1:6379> SMEMBERS users
1) "ww"
2) "ls"
3) "zs"
127.0.0.1:6379> SREM users ww
(integer) 1
127.0.0.1:6379> SMEMBERS users
1) "ls"
2) "zs"
```

```shell
127.0.0.1:6379> SCARD users
(integer) 2
127.0.0.1:6379> SISMEMBER uses zs
(integer) 0
127.0.0.1:6379> SISMEMBER users ww
(integer) 0
```

#### 扩展操作

业务场景1：

每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？

业务分析：

- 系统分析出各个分类的最新或最热点信息条目并组织成set集合
- 随机挑选出其中部分信息
- 配合用户关注信息分类中的热点信息组织成展示的全信息集合

解决方案：

- 随机获取集合中指定数量的数据

```shell
127.0.0.1:6379> SADD news n1
(integer) 1
127.0.0.1:6379> SADD news n2
(integer) 1
127.0.0.1:6379> SADD news n3
(integer) 1
127.0.0.1:6379> SADD news n4
(integer) 1
127.0.0.1:6379> SRANDMEMBER news 1
1) "n3"
127.0.0.1:6379> SRANDMEMBER news 1
1) "n2"
127.0.0.1:6379> SCARD news
(integer) 4
127.0.0.1:6379> SRANDMEMBER news 3
1) "n4"
2) "n2"
3) "n3"
```

- 随机获取集合中的某个数据并将数据移除集合

```shell
127.0.0.1:6379> SPOP news
"n3"
127.0.0.1:6379> SMEMBERS news
1) "n4"
2) "n1"
3) "n2"
127.0.0.1:6379> SPOP news 2
1) "n4"
2) "n1"
127.0.0.1:6379> SMEMBERS news
1) "n2"
```

**`redis`应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游路线，应用APP推荐，大V推荐等**

业务场景2：

- 脉脉为了促进用户间的交流，保障业务成单率的提升，需要让每位用户拥有大量的好友，事实上职场新人具有更多的职场好友，如何快速积累更多的好友？

- 新浪微博为了增加用户热度，提高用户留存度，需要微博用户在关注更多的人，以此获取更多的信息或热门话题，如何提高用户关注他人的总量？
- QQ新用户入网年龄越来越低，这些用户的朋友圈交际圈非常小，往往集中在一所学校甚至一个班级中，如何帮助用户快速积累好友用户带来更多的活跃度？

- 微信公众号是微信信息流通的渠道之一，增加用户关注的公众号成为提高用户活跃度的一种方式，如何帮助用户积累更多关注的公众号？
- 美团外卖为了提升成单量，必须帮助用户挖掘没事需求，如何推荐给用户最适合自己的美食？

有多少朋友关注？

解决方案：

- 求两个集合的交集、并集、差集

```shell
127.0.0.1:6379> SADD u1 a1
(integer) 1
127.0.0.1:6379> SADD u1 s1
(integer) 1
127.0.0.1:6379> SADD u1 b1
(integer) 1
127.0.0.1:6379> SADD u2 a1
(integer) 1
127.0.0.1:6379> SADD u2 w1
(integer) 1
127.0.0.1:6379> SINTER u1 u2
1) "a1"
127.0.0.1:6379> SUNION u1 u2
1) "w1"
2) "b1"
3) "a1"
4) "s1"
127.0.0.1:6379> SDIFF u1 u2
1) "b1"
2) "s1"
```

- 求两个集合的交集、并集、差集并存储到指定集合中

```shell
127.0.0.1:6379> SINTERSTORE u3 u1 u2
(integer) 1
127.0.0.1:6379> SMEMBERS u3
1) "a1"
```

- 将指定数据从原始集合中移动到目标集合中

```shell
127.0.0.1:6379> SMOVE u2 u1 w1
(integer) 1
127.0.0.1:6379> SMEMBERS u1
1) "w1"
2) "b1"
3) "a1"
4) "s1"
```

- `redis`应用于同类信息的关联搜索，二度关联搜索，深度关联搜索
- 显示共同好友（一度）
- 显示共同关注（一度）
- 由用户A出发，获取到好友用户B的好友信息列表（一度）

**注意事项**：

- `set`类型不允许数据重复，如果添加的数据在`set`中已经存在，将只保留一份
- `set`虽然与`hash`的存储结构相同，但是无法启用`hash`中存储值的空间

#### set类型应用场景

业务场景1：

集团公司有12000员工，内部OA系统中具有700多个角色，3000多个业务操作，23000多种数据，每位员工具有一个或多个角色，如何快速进行业务操作的权限校验？

解决方案：

- 根据用户`id`获取所有角色
- 根据用户所有角色获取用户所有操作权限放入`set`集合中
- 根据用户所有角色获取用户所有数据放入`set`集合中

```shell
127.0.0.1:6379> SADD rid:001 getall
(integer) 1
127.0.0.1:6379> SADD rid:001 getById
(integer) 1
127.0.0.1:6379> SADD rid:002 getCount
(integer) 1
127.0.0.1:6379> SADD rid:002 getall
(integer) 1
127.0.0.1:6379> SADD rid:002 insert
(integer) 1
127.0.0.1:6379> SUNIONSTORE uid:007 rid:001 rid:002
(integer) 4
127.0.0.1:6379> SMEMBERS uid:007
1) "insert"
2) "getCount"
3) "getall"
4) "getById"
```

推荐：redis提供基础数据，不提供检验结果，不推荐下面的方式

```shell
127.0.0.1:6379> SISMEMBER uid:007 insert
(integer) 1
```

**redis应用于同类型不重复数据的合并操作**

业务场景2：

公司对旗下新的网站做推广，统计网站的PV（访问量），UV（独立客户），IP（独立IP）

PV：网站被访问次数，可通过刷新页面提供访问量

UV：网站被不同用户访问的次数，可通过cookie统计访问量，相同用户切换IP地址，UV不变

IP：网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变

解决方案：

- 利用`set`集合的数据去重特征，记录各种访问数据

- 建立`string`类型数据，利用`incr`统计日访问量（PV）
- 建立`set`模型，记录不同`cookie`数量（UV）
- 建立`set`模型，记录不同IP数量（IP）

```shell
127.0.0.1:6379> SADD ips 1.2.3.4
(integer) 1
127.0.0.1:6379> SADD ips 2.3.4.5
(integer) 1
127.0.0.1:6379> SADD ips 2.3.4.5
(integer) 0
127.0.0.1:6379> SCARD ips
(integer) 2
```

**redis 应用于用类型数据的快速去重**

业务场景3：

黑名单白名单

解决方案：

`set`去重

### 5.5、sorted_set 类型

- 新的存储需求：数据排列有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式
- 需要的存储结构：新的存储模型，可以保存可排序的数据
- `sorted_set`类型：在set的存储结构基础上天机可排序字段

#### 基本操作

```shell
127.0.0.1:6379> ZADD scores 94 zs
(integer) 1
127.0.0.1:6379> ZADD scores 100 ls
(integer) 1
127.0.0.1:6379> ZADD scores 46 zl
(integer) 1
127.0.0.1:6379> ZADD scores 60 ww
(integer) 1
127.0.0.1:6379> ZRANGE scores 0 -1
1) "zl"
2) "ww"
3) "zs"
4) "ls"
127.0.0.1:6379> ZRANGE scores 0 -1 withscores
1) "zl"
2) "46"
3) "ww"
4) "60"
5) "zs"
6) "94"
7) "ls"
8) "100"
127.0.0.1:6379> ZREVRANGE scores 0 -1 withscores
1) "ls"
2) "100"
3) "zs"
4) "94"
5) "ww"
6) "60"
7) "zl"
8) "46"
127.0.0.1:6379> ZREM scores ww
(integer) 1
127.0.0.1:6379> ZREVRANGE scores 0 91 withscores
1) "ls"
2) "100"
3) "zs"
4) "94"
5) "zl"
6) "46"
```

- 按条件获取数据

```shell
127.0.0.1:6379> ZADD scores 80 ab
(integer) 1
127.0.0.1:6379> ZADD scores 49 cd
(integer) 1
127.0.0.1:6379> ZRANGEBYSCORE scores 50 80 withscores
1) "ab"
2) "80"
```

- 条件删除数据

```shell
127.0.0.1:6379> ZREMRANGEBYRANK scores 0 1
(integer) 2
```

- 获取集合数据总量

```shell
127.0.0.1:6379> ZCARD scores
(integer) 3
127.0.0.1:6379> ZCOUNT scores 60 80
(integer) 1
```

- 集合交集、并集操作

```shell
127.0.0.1:6379> zadd s1 50 aa 60 bb 70 cc
(integer) 3
127.0.0.1:6379> ZADD s2 60 aa 40 bb 90 dd
(integer) 3
127.0.0.1:6379> ZADD s3 70 aa 20 bb 100 dd
(integer) 3
127.0.0.1:6379> ZINTERSTORE s4 3 s1 s2 s3
(integer) 2
127.0.0.1:6379> ZRANGE s4 0 -1 withscores
1) "bb"
2) "120"
3) "aa"
4) "180"
```

#### 扩展操作

业务场景1：

各类资源网站TOP10（电影，歌曲，文档，电商，游戏）

游戏好友亲密度

聊天室活跃度统计

业务分析：

- 为所有参与排名的资源建立排序依据

解决方案：

- 获取数据对应的索引（排名）

```shell
127.0.0.1:6379> ZADD movies 143 aa 97 bb 201 cc
(integer) 3
127.0.0.1:6379> ZRANK movies bb
(integer) 0
127.0.0.1:6379> ZREVRANK movies bb
(integer) 2
```

- score值获取与修改

```shell
127.0.0.1:6379> ZSCORE movies aa
"143"
127.0.0.1:6379> ZINCRBY movies 1 aa
"144"
```

**redis应用于计数器组合排序功能对应的排名**

`sorted_set`类型数据操作的注意事项：

- `score`保存的数据存储是64位，整数范围是...
- `score`保存的数据也可以是一个双精度的`double`值，可能会丢失精度，慎重使用

- 底层结构基于set结构，因此数据不能重复，如果添加相同数据，`score`值被反复覆盖，保存最后一次修改的结果

```shell
127.0.0.1:6379> ZADD test1 11 aa
(integer) 1
127.0.0.1:6379> ZRANGE test1 0 -1 withscores
1) "aa"
2) "11"
127.0.0.1:6379> ZADD test1 22 aa
(integer) 0c
127.0.0.1:6379> ZRANGE test1 0 -1 withscores
1) "aa"
2) "22"
```

#### sorted_set 类型应用场景

业务场景1：

基础服务+增值服务类网站会设定给为会员的试用，让用户充分体验会员优势。观影试用VIP、游戏VIP、云盘下载体验VIP。VIP体验到期后，怎么管理？

网站定期开启投票、讨论，限时进行，逾期作废。如何有效管理此类过期信息。

解决方案：

- 对于基于时间线限定的任务处理，将处理时间记录为score值，利用排序功能区分处理的先后顺序
- 记录下一个要处理的时间，到期后处理对应任务，移除redis中的记录，冰激凌下一个要处理的时间
- 新任务加入时，判定并更新当前下一个要处理的任务时间
- 为提升`sorted_set`的性能，通常将任务根据特征存储成若干个`sorted_set`

```shell
127.0.0.1:6379> ZADD tx 1508902345 uid:001
(integer) 1
127.0.0.1:6379> ZADD tx 1508902389 uid:007
(integer) 1
127.0.0.1:6379> ZADD tx 1510856556 uid:888
(integer) 1
127.0.0.1:6379> ZRANGE tx 0 -1 withscores
1) "uid:001"
2) "1508902345"
3) "uid:007"
4) "1508902389"
5) "uid:888"
6) "1510856556"
127.0.0.1:6379> time
1) "1590458849"
2) "691180"
```

**redis应用于定时任务执行顺序管理或任务过期管理**

业务场景2：

任务、消息权重设定应用

当任务或者消息待处理，形成了任务队列或消息队列，对于高优先级的任务要保证对其优先处理，如何实现？

解决方案：

```shell
127.0.0.1:6379> ZADD tasks 4 order:id:005
(integer) 1
127.0.0.1:6379> zadd tasks 1 order:id:442
(integer) 1
127.0.0.1:6379> zadd tasks 9 order:id:324
(integer) 1
127.0.0.1:6379> ZREVRANGE tasks 0 -1 withscores
1) "order:id:324"
2) "9"
3) "order:id:005"
4) "4"
5) "order:id:442"
6) "1"
127.0.0.1:6379> ZREVRANGE tasks 0 0
1) "order:id:324"
127.0.0.1:6379> ZREM tasks order:id:324
(integer) 1
```

**redis 应用于即时任务、消息队列执行管理**

### 5.6、数据类型实践案例

#### 业务场景1：

百度自研用户给评价语义识别服务，免费开放给企业使用，同时训练百度自己的模型，现对使用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用

解决方案：

- 设计计数器，记录调用次数，用于控制业务执行次数。以用户id作为key，使用次数作为value
- 在调用前获取次数，判断是否超过限定次数
  - 不超过次数的情况下，每次调用计数+1
  - 业务调用失败，计数-1
- 为计数器设置生命周期为指定周期，例如1秒、1分钟，自动清空周期内使用次数

解决方案改良：

- 取消最大值的判定，利用incr操作超过最大值抛出异常的形式替代每次判断是否大于最大值（比如10）
- 判断是否为nil
  - 如果是，设置Max-次数
  - 如果不是，计数+1
  - 业务调用失败，计数-1
- 遇到异常即+操作超过上限，视为使用达到上限

```shell
127.0.0.1:6379> get 1
(nil)
127.0.0.1:6379> SETEX 1 60 9223372036854775797
OK
127.0.0.1:6379> INCR 1
(integer) 9223372036854775798
127.0.0.1:6379> INCR 1
(integer) 9223372036854775799
127.0.0.1:6379> INCR 1
(integer) 9223372036854775800
127.0.0.1:6379> INCR 1
(integer) 9223372036854775801
127.0.0.1:6379> INCR 1
(integer) 9223372036854775802
127.0.0.1:6379> INCR 1
(integer) 9223372036854775803
127.0.0.1:6379> INCR 1
(integer) 9223372036854775804
127.0.0.1:6379> INCR 1
(integer) 9223372036854775805
127.0.0.1:6379> INCR 1
(integer) 9223372036854775806
127.0.0.1:6379> INCR 1
(integer) 9223372036854775807
127.0.0.1:6379> INCR 1
(error) ERR increment or decrement would overflow
127.0.0.1:6379> get 1
"9223372036854775807"
127.0.0.1:6379> get 1
(nil)
```

**redis应用于限时按次结算的服务控制**

#### 业务场景2：

使用微信的过程中，当微信接收消息后，会默认将最近接受的消息置顶，当多个好友及关注的订阅号同时发送消息时，改排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，该消息按照什么样的顺序显示？

业务分析：

100：自己，200,300,400,500：好友，400置顶

300发消息，400发消息，200发消息，200发消息，300发消息

解决方案：

- 依赖`list`的数据具有顺序的特征对消息进行管理，将`list`结构作为栈使用
- 对置顶与普通会话分别创建独立的`list`分别管理
- 当某个`list`中接收到用户消息后，将消息发送方的`id`从`list`的一侧加入list
- 多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id
- 推送消息时先推送指定会话`list`，在推送普通会话`list`，推送完成的`list`清除所有数据
- 消息的数量，也就是微信用户对话数量爱用计数器的思想另行记录，伴随`list`操作同步更新

**redis应用于基于时间顺序的数据操作，而不关注具体时间**

#### 解决方案列表

- 用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性
- 控制数据的生命周期，通过数据是否时效控制业务行为，适用于所有具有时效性限定控制的操作
- 应用于各种结构型和非结构型高热度数据访问加速
- 应用于购物车数据存储设计
- 应用于抢购，限购类、向量发放优惠券、激活码等业务的数据存储设计
- 应用于具有操作先后顺序的数据控制
- 应用于最新消息展示
- 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐
- 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索
- 应用于同类型不重复数据的合并，取交集操作
- 应用于数据的快速去重
- 应用于基于黑名单于白名单设定的服务控制
- 应用于计数器组合排序功能对应的排名
- 应用于定时任务执行顺序管理或任务过期管理
- 应用于及时任务、消息队列执行管理
- 应用于按次计算的服务控制
- 应用于基于时间顺序的数据操作，而不关注具体时间

## 6、key 通用命令

#### 6.1、基本操作

```shell
127.0.0.1:6379> set string string
OK
127.0.0.1:6379> HSET hash hash hash
(integer) 1
127.0.0.1:6379> LPUSH list a b c
(integer) 3
127.0.0.1:6379> type list
list
127.0.0.1:6379> EXISTS string
(integer) 1
127.0.0.1:6379> del list
(integer) 1
```

#### 6.2、扩展操作

- 为指定`key`设置有效期

```shell
127.0.0.1:6379> set str str
OK
127.0.0.1:6379> lpush list1 list1
(integer) 1
127.0.0.1:6379> LPUSH list2 list2
(integer) 1
127.0.0.1:6379> EXPIRE str 3
(integer) 1
127.0.0.1:6379> get str
"str"
127.0.0.1:6379> get str
(nil)
```

- 获取`key`的有效时间

```shell
127.0.0.1:6379> EXPIRE list1 30
(integer) 1
127.0.0.1:6379> TTL list1
(integer) 27
127.0.0.1:6379> ttl str
(integer) -2
127.0.0.1:6379> ttl list1
(integer) -2
127.0.0.1:6379> ttl list2
(integer) -1
```

- 切换`key`从时效性转换为永久性

```shell
127.0.0.1:6379> PERSIST list2
(integer) 0
127.0.0.1:6379> EXPIRE list2 60
(integer) 1
127.0.0.1:6379> ttl list2
(integer) 56
127.0.0.1:6379> PERSIST list2
(integer) 1
127.0.0.1:6379> ttl list2
(integer) -1
```

- 查询key 

规则： * 任意数量的任意符号   ？配合一个任意符号  []匹配一个指定符号

```shell
127.0.0.1:6379> keys *
1) "list2"
```

- 为`key`改名

```shell
127.0.0.1:6379> set str1 str1
OK
127.0.0.1:6379> set str2 str2
OK
127.0.0.1:6379> set str3 str3
OK
127.0.0.1:6379> RENAME str1 str4
OK
127.0.0.1:6379> KEYS *
1) "str2"
2) "str3"
3) "str4"
127.0.0.1:6379> get str4
"str1"
127.0.0.1:6379> RENAME str3 str2
OK
127.0.0.1:6379> KEYS *
1) "str2"
2) "str4"
127.0.0.1:6379> get str2
"str3"
127.0.0.1:6379> RENAMENX str2 str4
(integer) 0
```

- 对所有`key`排序

```shell
127.0.0.1:6379> LPUSH aa 123
(integer) 1
127.0.0.1:6379> LPUSH aa 321
(integer) 2
127.0.0.1:6379> LPUSH aa 222
(integer) 3
127.0.0.1:6379> LRANGE aa 0 -1
1) "222"
2) "321"
3) "123"
127.0.0.1:6379> SORT aa
1) "123"
2) "222"
3) "321"
127.0.0.1:6379> LRANGE aa 0 -1
1) "222"
2) "321"
3) "123"
```

- 其他`key`通用操作

```shell
127.0.0.1:6379> help @generic
```

## 7、数据库通用操作

key的重复问题？

解决方案

- `redis`为每个服务提供16个数据库，编号0到15
- 每个数据库之间的数据相互独立

![](images/redis%E6%95%B0%E6%8D%AE%E5%BA%93.png)

#### 7.1、基本操作

- 切换数据库

```shell
127.0.0.1:6379> SELECT 1
OK
```

- 其他操作

```shell
127.0.0.1:6379> ECHO aaaaa
"aaaaa"
127.0.0.1:6379> ping
PONG
```

#### 7.2、db相关操作

- 数据移动

```shell
127.0.0.1:6379> set name jack
OK
127.0.0.1:6379> MOVE name 1
(integer) 1
127.0.0.1:6379> get name
(nil)
127.0.0.1:6379> select 1
OK
127.0.0.1:6379[1]> get name
"jack"
```

- 数据清除

```shell
127.0.0.1:6379[1]> FLUSHDB
OK
127.0.0.1:6379[1]> FLUSHALL
OK
127.0.0.1:6379[1]> set name aaa
OK
127.0.0.1:6379[1]> DBSIZE
(integer) 1
```


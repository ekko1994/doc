# 程序计数器

- 每个线程：程序计数器、栈、本地栈。
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）。
  - 每个JVM只有一个`Runtime`实例

## 线程

- 线程是一个程序里的运行单元。JVM允许一个应用有多个线程运行的执行。
- 在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射。
  - 当一个Java线程准备好执行之后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。
- 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的`run()`方法。

## 程序计数器（PC寄存器）

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

![image-20211227120205305](./images/image-20211227120205305.png)

- 它是一块很小的内存空间，几乎可以忽略不计。也是运行最快的存储区域。
- 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是唯一一个在Java虚拟机中没有任何`OutOfMemoryError`情况的区域。

![PC寄存器](../images/PC寄存器.png)

### 两个常见问题

**使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**

![image-20211227121613877](./images/image-20211227121613877.png)

因为CPU需要不停的切换各个线程，这时候切换回来后，就得知道接着从哪开始继续执行。

JVM字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

**PC寄存器为什么会被设定为线程私有？**

![image-20211227130800926](./images/image-20211227130800926.png)

我们知道多线程在一个特定的时间段内只会执行某一个线程的方法，CPU会不停地任务切换，这样必会导致经常中断或回复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

